export interface BlogPost {
  slug: string;
  title: string;
  description: string;
  category: string;
  order: number;
  lastUpdated: string;
  content: string;
}

export const blogs: BlogPost[] = [
  {
    slug: "workshop-on-rest-api-design-day-01",
    title: "Workshop on REST API Design (Day 01)",
    description:
      "This workshop, conducted over three days, focuses on the **principles and best practices of REST API design**, especially for large-scale, maintainable applications used by multiple consumers. It targets developers with **at least 1-2 years of API development experience**, aiming to clear misconceptions and enhance understanding beyond just returning JSON objects from an API.",
    category: "API TESTING (STACK LEARNER)",
    order: 1,
    lastUpdated: "12/18/2025",
    content:
      "### Summary of Workshop on REST API Design for Scalable Applications\n\nThis workshop, conducted over three days, focuses on the **principles and best practices of REST API design**, especially for large-scale, maintainable applications used by multiple consumers. It targets developers with **at least 1-2 years of API development experience**, aiming to clear misconceptions and enhance understanding beyond just returning JSON objects from an API.\n\n---\n\n### Workshop Overview and Objectives\n\n- **Purpose:** Teach better API design thinking for large organizations, focusing on **scalable, maintainable APIs** that support multiple consumers over years.\n- **Target Audience:** Intermediate to advanced developers, not beginners or hobbyists.\n- **Duration:** Three days with progressive topics, quizzes, and Q&A sessions.\n\n---\n\n### Workshop Structure and Key Topics\n\n| Day | Topics Covered |\n|-----|-----------------------------------------------------------------------------------------------------|\n| 1   | Introduction to REST, importance of API design, elements of scalable APIs, **6 constraints of RESTful APIs**, API maturity measurement, good API characteristics. |\n| 2   | Handling partial responses, managing query parameters, response structuring, cache control patterns, API versioning techniques, hands-on exercises. |\n| 3   | OpenAPI specification, API documentation using Swagger, API security best practices, effective API management and governance, real-world API design examples (WooCommerce, GitHub APIs). |\n\n---\n\n### Core Concepts and Key Insights\n\n- **API Definition:** An API is a **contract between producer and consumer(s)** defining how data and functionality are exposed and consumed. It is **not limited to REST**; other styles include SOAP, GraphQL, gRPC, and Webhooks.\n\n- **REST API:** REST stands for **Representational State Transfer**—an architectural style governing how resources are identified, addressed, and exchanged over HTTP. REST APIs must satisfy **six key constraints**:\n  1. Client-Server architecture\n  2. Statelessness\n  3. Cacheability\n  4. Uniform interface\n  5. Layered system\n  6. Code on demand (optional, rarely used)\n\n- **Statelessness:** Each request must contain all necessary information for the server to understand and process it, enabling horizontal scalability by eliminating server-stored session state.\n- **Cacheability:** APIs should explicitly define cache policies to improve performance and reduce latency. Cache-control headers distinguish between public and private caches.\n- **Uniform Interface:** Consistent resource identification (via URIs), manipulation through representations (JSON/XML), self-descriptive messages, and hypermedia-driven navigation (HATEOAS) are vital for usability and discoverability.\n\n- **API Design Importance:**\n  - Ensures **interoperability** across platforms, languages, and tech stacks.\n  - Enables **reuse** and **adaptability** to changing business needs and technologies.\n  - Improves **developer experience** by providing consistent, well-documented interfaces.\n  - Facilitates long-term **maintainability** and **scalability** of APIs.\n  - Supports **security** by defining clear authentication, authorization, and throttling strategies.\n\n- **API First Approach:** Focus on designing APIs before coding, including defining endpoints, request/response schemas, error handling, and documentation. This approach accelerates development, testing, and collaboration across teams.\n\n---\n\n### Real-World Examples and Best Practices\n\n- **Case Study: Imran's E-commerce Project**  \n  Imran built a scalable REST API for an e-commerce platform with core features like product catalog, shopping cart, search, and payments. Despite successful delivery, the API lacked consistency, documentation, and clarity, causing integration issues for the client's frontend team. This highlighted the **need for standardized API design and documentation**.\n\n- **WooCommerce REST API**  \n  Demonstrated as a well-documented, mature API with clearly defined endpoints, request parameters, response schemas, status codes, and authentication mechanisms. It showcases how **good API design reduces development friction** and improves integration.\n\n- **GitHub API**  \n  Exhibits complex resource nesting with clear documentation, multiple versions, and extensive endpoint coverage, demonstrating **API maturity and management at scale**.\n\n---\n\n### API Maturity Model\n\n- **Level 0:** RPC-style plain XML or JSON APIs without RESTful constraints.\n- **Level 1:** Resource-based APIs, but often with a single endpoint and lacking HTTP method usage.\n- **Level 2:** Proper use of HTTP methods (GET, POST, PUT, DELETE) with resource-based URIs; considered partially RESTful.\n- **Level 3:** Hypermedia controls (HATEOAS) allowing dynamic discovery and navigation; fully RESTful APIs.\n\nMost real-world APIs are at **Level 2**, with Level 3 representing the ideal maturity.\n\n---\n\n### Developer and Organizational Considerations\n\n- API design is typically a **team effort** involving software architects, senior developers, and other stakeholders.\n- Good API design requires understanding the **business domain and use cases**, not just technical implementation.\n- Documentation, versioning, and consistent naming conventions are essential to prevent confusion and integration issues.\n- API design decisions impact the entire software lifecycle, including testing, deployment, scaling, security, and governance.\n- Developers must balance between **over-engineering** and delivering practical, maintainable solutions.\n\n---\n\n### Common Challenges Addressed\n\n- Misunderstanding REST API as \"just returning JSON.\"\n- Lack of consistent request/response formats causing confusion.\n- Absence of proper documentation and versioning leading to integration failures.\n- Stateful APIs breaking statelessness constraint, impeding scalability.\n- Managing API security (authentication, authorization) effectively.\n- Handling large-scale distributed systems with layered architectures (e.g., API gateways, proxies, caches).\n- Adapting to evolving technology stacks and third-party dependencies with proper abstraction and modular design.\n\n---\n\n### Important Recommendations\n\n- Follow **REST constraints strictly** to ensure API scalability and interoperability.\n- Embrace **OpenAPI Specification** (Swagger) for API design, documentation, and contract-first development.\n- Design APIs with **developer experience** in mind—consistency, clarity, and predictability.\n- Use **hypermedia links** to enable discoverability and smooth client navigation.\n- Plan for **versioning** and backward compatibility from the start.\n- Implement **security best practices**: token-based authentication, role-based access, throttling, secure headers.\n- Adopt **layered architecture** for modularity, observability, and maintainability.\n- Use **stateless design** to support horizontal scaling and fault tolerance.\n- Cache responses appropriately to reduce latency and server load.\n\n---\n\n### Summary Table: REST API 6 Constraints\n\n| Constraint              | Description                                                                                  | Importance                              |\n|-------------------------|----------------------------------------------------------------------------------------------|-----------------------------------------|\n| Client-Server           | Separation of client and server concerns                                                     | Enables independent evolution           |\n| Stateless               | Each request contains all necessary info; no server-side session state                       | Supports scalability and reliability    |\n| Cacheable               | Responses must explicitly define cacheability                                                | Improves performance and latency        |\n| Uniform Interface       | Consistent resource identification, manipulation, self-descriptive messages, hypermedia     | Simplifies and standardizes communication |\n| Layered System          | Architecture composed of hierarchical layers (e.g., proxies, gateways)                       | Enhances scalability and security       |\n| Code on Demand (opt)    | Server can send executable code to client (rarely used)                                      | Extends client capabilities             |\n\n---\n\n### Terminology and Definitions\n\n| Term                    | Definition                                                                                   |\n|-------------------------|----------------------------------------------------------------------------------------------|\n| API (Application Programming Interface) | A contract enabling data and functionality exchange between producers and consumers.         |\n| REST (Representational State Transfer)  | An architectural style for distributed hypermedia systems emphasizing stateless communication and resource manipulation via HTTP. |\n| Statelessness           | Server does not store client state between requests; client sends all info needed per request. |\n| Hypermedia (HATEOAS)    | Hypermedia as the engine of application state; responses include links guiding next actions. |\n| OpenAPI Specification   | A standard for describing RESTful APIs, enabling machine and human-readable documentation.  |\n| API Maturity Levels     | Levels 0-3 describing the extent to which an API adheres to REST principles.                |\n| Cache Control           | Mechanism to specify caching policies for HTTP responses.                                    |\n| API Gateway             | A server that acts as an API front-end, handling routing, security, and rate limiting.      |\n\n---\n\n### Final Remarks\n\n- REST API design is a **critical, intentional decision-making process** that precedes coding.\n- Well-designed APIs are the foundation of modern scalable, maintainable software systems.\n- The workshop emphasizes **API-first development** with a focus on **design, documentation, security, and governance**.\n- Practical examples (WooCommerce, GitHub) illustrate real-world API design challenges and solutions.\n- Developers are encouraged to **think beyond coding** and incorporate **business understanding and best practices** for long-term success.\n\n---\n\nThis comprehensive workshop content provides a **solid foundation for designing scalable, reliable, and maintainable REST APIs**, essential for developers aspiring to work in large organizations or build public-facing APIs.\n\n---\n\n### Resources\n\nThis summary is based on the following workshop:\n\n **[Day 1: REST API From Concepts to Constraints | REST API Design Workshop by Stack Learner](https://www.youtube.com/watch?v=EbHf2aCuPVM&t=2715s)**\n\n*`Credits:Stack Learner - REST API Design Workshop Series`*",
  },
  {
    slug: "workshop-on-rest-api-design-day-02",
    title: "Workshop on REST API Design (Day 02)",
    description:
      "This workshop, conducted over three days, focuses on the **principles and best practices of REST API design**, especially for large-scale, maintainable applications used by multiple consumers. It targets developers with **at least 1-2 years of API development experience**, aiming to clear misconceptions and enhance understanding beyond just returning JSON objects from an API.",
    category: "API TESTING (STACK LEARNER)",
    order: 1,
    lastUpdated: "12/23/2025",
    content:
      "#### Partial Responses\n- **Partial response** allows API consumers to request only specific fields of a resource, reducing unnecessary data transfer.\n- Clients specify desired fields via query parameters e.g., **fields=name,price,photo**.\n- Benefits:\n  - **Reduces bandwidth usage** by sending only necessary data.\n  - **Improves response time and performance**, especially for clients with limited network.\n  - Avoids over-fetching large datasets.\n- Example: A product resource may have many fields; mobile apps may only need **name** and **photo**.\n- Without partial responses, full data is sent, causing latency and bandwidth wastage.\n\n#### Query Parameters\nQuery parameters are a fundamental aspect of HTTP requests used to specify information for a resource retrieval or manipulation operation.\n- Used for **filtering**, **sorting**, **searching**, and **pagination**.\n- Examples:\n  - Filtering products by category or price range.\n  - Sorting by price ascending/descending.\n  - Pagination using **limit** and **page** parameters to retrieve manageable chunks of data.\n- Query parameters enable flexible, client-driven data retrieval.\n\n#### Pagination\n- Essential when dealing with large datasets (e.g., 1 million products).\n- Prevents overloading the client and network by limiting data per request.\n- Typical parameters: **limit** (items per page), **page** (page number).\n- Response includes metadata such as current page, total pages, total items, and links for navigation.\n- Ensures scalable API consumption.\n\n#### Error Handling and Consistency\n- Proper HTTP status codes: 200 (OK), 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404 (Not Found), 422 (Unprocessable Entity), 500 (Internal Server Error).\n- Error responses should be:\n  - **Consistent in format** across the API.\n  - Include descriptive messages, error codes, hints for troubleshooting, and a **trace ID**.\n- Trace IDs help developers quickly identify root causes using tools like **OpenTelemetry** or **Sentry**.\n- Avoid exposing sensitive internal information (e.g., database queries) in error responses.\n### Cacheability\nResponses from the server should be explicitly labeled as cacheable or non-cacheable.\n\n#### HTTP Caching (Cache-Control Headers)\n- Critical for **scalability, performance, and reducing latency**.\n- Controls what data is cached, by whom, and for how long.\n- Common directives:\n  - **public** — response can be cached by any cache (browser, proxy).\n  - **private** — response cached only by the client’s browser.\n  - **no-cache** — requires validation before use.\n  - **no-store** — no caching allowed (used for sensitive data).\n  - **max-age** — duration (in seconds) to cache the response.\n  - **S-Max-Age** — Similar to max-age\n- Caching can happen at multiple levels: client, proxy, ISP.\n- Example: Products list responses can be cached for a minute, reducing unnecessary server hits.\n\n#### ETag (Entity Tag) Headers and Conditional Requests\n- ETag is a unique hash representing the current version of a resource.\n- Server sends ETag in response headers.\n- Client sends ETag back in **If-None-Match** header during subsequent requests.\n- Server compares ETag values:\n  - If unchanged, responds with **304 Not Modified** (no body), saving bandwidth.\n  - If changed, sends updated resource data with new ETag.\n- ETag enables **efficient cache validation** and **avoids redundant data transfer**.\n- Implementation involves generating a hash (e.g., SHA1) of resource content or metadata.\n- Helpful for large payloads and frequently accessed resources.\n\n#### API Versioning\n- API versioning manages **changes and backward compatibility** as APIs evolve.\n- Prevents breaking existing clients when introducing new features or breaking changes.\n- Two main categories of changes:\n  - **Breaking Changes**: Modify existing functionality, requiring a new API version.\n  - **Non-breaking Changes**: Add new features or optimize without affecting existing clients.\n- Versioning strategies:\n  - **URL-based** (e.g., `/api/v1/products`).\n  - **Header-based** (passing version info in HTTP headers).\n  - **Composite** (combining URL and headers).\n- Best practices:\n  - Maintain clear **documentation** and **migration guides**.\n  - Use **deprecation warnings** for old versions.\n  - Provide **backward compatibility** as much as possible.\n  - Encourage clients to upgrade gradually.\n- Example:\n  - Version 1 might return product data with a **data** property.\n  - Version 2 changes the response format to **products** property (breaking change).\n- Proper versioning allows multiple API versions to coexist, supporting diverse client needs.\n\n---\n\n### Markdown Table: HTTP Status Codes Discussed\n\n| Status Code | Meaning               | When to Use                                           |\n|-------------|-----------------------|-------------------------------------------------------|\n| 200         | OK                    | Successful requests                                   |\n| 304         | Not Modified          | Cached response still valid                           |\n| 400         | Bad Request           | Invalid request data                                  |\n| 401         | Unauthorized          | Authentication required                               |\n| 403         | Forbidden             | Insufficient permissions                              |\n| 404         | Not Found             | Resource does not exist                               |\n| 422         | Unprocessable Entity  | Validation or semantic errors                         |\n| 500         | Internal Server Error | Server-side failure                                   |\n\n---\n\n### Best Practices & Key Insights\n\n- Implement **partial responses** to avoid over-fetching.\n- Use **query parameters** for flexible data access.\n- Keep **error responses consistent** and traceable.\n- Leverage **Cache-Control** and **ETag** for performance.\n- Apply **API versioning** for breaking changes.\n- Maintain documentation and migration guides.\n- Monitor API usage and deprecate responsibly.\n- Use **Redis or server-side caching** for heavy reads.\n- Consider **GraphQL** only when REST becomes limiting.\n\n---\n\n### Conclusion\n\nThis workshop delivers a practical, real-world blueprint for building scalable REST APIs. By combining partial responses, caching strategies, consistent error handling, and disciplined versioning, teams can ship APIs that scale cleanly while keeping clients happy and unbroken.\n\n\n\n---\n\n### FAQ (Extracted from Q&A)\n\n**Should we switch to GraphQL for partial responses?**  \n  Not required. REST with partial responses works for most use cases.\n\n**How to handle ETag in Node.js?**  \n  Implement via middleware or custom hashing logic.\n\n**How to avoid duplication in versioned APIs?**  \n  Separate routing layers, reuse service logic.\n\n**When to use API versioning?**  \n  Always for breaking changes.\n\n**How to cache frequently changing data?**  \n  Don’t. Cache only stable or semi-static data.\n### Resources\n\nThis summary is based on the following workshop:\n\n **[Day 2: REST API Partial Responses, Error Handling, Caching, and Version Control | REST API Design](https://www.youtube.com/watch?v=orn9N90dcVY&t=4459s)**\n\n`Credits: Stack Learner - REST API Design Workshop Series`",
  },
  {
    slug: "google-dorks-and-oauth-recon",
    title: "Google Dorks & OAuth Recon Cheatsheet",
    description:
      "A curated collection of Google Dorks and UrlScan queries for sensitive file discovery, OAuth attack surface mapping, and vulnerability research",
    category: "Bug Hunting",
    order: 2,
    lastUpdated: "12/17/2025",
    content:
      '# Google Dorks & OAuth Recon Cheatsheet\n\nThis note contains high-signal Google Dorks and UrlScan queries used for reconnaissance, sensitive data exposure, and OAuth attack surface mapping.\n\n---\n\n## Sensitive Files & Data Exposure (Google Dorks)\n\n```text\nsite:domain.com ext:pdf\nsite:domain.com (ext:pdf OR ext:doc OR ext:docx OR ext:zip OR ext:bak OR ext:txt OR ext:ppt OR ext:pptx OR ext:xls OR ext:xlsx)\nsite:domain.com ext:xls\nsite:domain.com ext:xlsx\nsite:target.com intitle:"Index of /backup"\nsite:target.com inurl:"/wp-content/uploads/"\nsite:target.com intitle:"Index of /database"\nsite:target.com ext:git "target.com"\nsite:target.com inurl:"/.git/config"\nsite:target.com filetype:java "password"\nsite:target.com filetype:pem "PRIVATE KEY"\nsite:target.com filetype:ppk intext:"PuTTY"\nsite:target.com inurl:"id_rsa" filetype:key\nsite:target.com intext:"PHPSESSID="\nsite:target.com intext:"session_token="\nsite:s3.amazonaws.com "target.com"\nsite:github.com "target.com" ("password" OR "API_KEY")\nsite:docs.google.com "target.com confidential"\nsite:target.com filetype:xls "private"\nsite:target.com filetype:xls inurl:"contact"\nsite:target.com filetype:xls inurl:"email.xls"\nsite:target.com allinurl:"admin" mdb\nsite:target.com inurl:"email" filetype:mdb\nsite:target.com inurl:"backup" filetype:mdb\nsite:target.com inurl:"*db" filetype:mdb\nsite:target.com inurl:".env"\n```\n\n---\n\n## Finding New HackerOne Programs\n\n```bash\nwaybackurls hackerone.com | grep "embedded_submissions/new"\n```\n\n---\n\n## OAuth Attack Surface Mapping (UrlScan)\n\n```text\ndomain:redacted.tld AND page.url:openid NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope=api NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope=full NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:full NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:access NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:system NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:backend NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:internal NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:intranet NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:extranet NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:admin NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:database NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:panel NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:callback NOT domain:microsoftonline.com NOT domain:google.com\n```\n\n---\n\n## OAuth High-Risk Scopes\n\n```text\npage.url:scope AND page.url:delete NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:write NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:share NOT domain:microsoftonline.com NOT domain:google.com NOT domain:amazoncognito.com\npage.url:scope AND page.url:upload NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:file NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:storage NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:permission NOT domain:microsoftonline.com NOT domain:google.com\npage.url:scope AND page.url:account NOT domain:microsoftonline.com NOT domain:google.com NOT domain:shopify.com\npage.url:refresh_token NOT domain:microsoftonline.com\n```\n\n---\n\n## OAuth Versioned Endpoints\n\n```text\npage.url:scope AND page.url:v1\npage.url:scope AND page.url:v2\npage.url:scope AND page.url:v3\npage.url:scope AND page.url:v4\n```\n\n---\n\n## Finding Unique URLs (Google Dork Patterns)\n\n```text\nsite:domain.tld inurl:& inurl:keyword\nsite:domain.tld inurl:& inurl:= inurl:keyword\nsite:domain.tld inurl:& inurl? inurl:keyword\nsite:domain.tld inurl:& inurl? inurl:= inurl:keyword\n```\n\n---\n\n## OAuth State Parameter Missing (CSRF Risk)\n\n```text\npage.url:scope NOT page.url:state AND page.url:redirect_uri\npage.url:scope NOT page.url:state AND page.url:auth\npage.url:scope NOT page.url:state AND page.url:oauth\npage.url:scope NOT page.url:state AND page.url:oauth2\npage.url:scope NOT page.url:state AND page.url:authorize\npage.url:scope NOT page.url:state AND page.url:client_id\npage.url:scope NOT page.url:state AND page.url:response_type\n```\n\n---\n\n## UrlScan OAuth Dork\n\n```text\npage.url:response_type AND page.url:code NOT domain:google.com NOT domain:microsoftonline.com\n```\n\n---\n\n## Learning from Real HackerOne Reports\n\n```text\nsite:hackerone.com "oauth"\n\n# Open Redirect\nsite:hackerone.com "oauth" "open redirect"\n\n# Misconfiguration\nsite:hackerone.com "oauth" "misconfiguration"\n\n# Account Takeover\nsite:hackerone.com "oauth" "account takeover"\n\n# Bypass\nsite:hackerone.com "oauth" "bypass"\n\n# XSS\nsite:hackerone.com "oauth" "XSS"\n\n# CSRF\nsite:hackerone.com "oauth" "CSRF"\n\n# Chained Bugs\nsite:hackerone.com inurl:reports "oauth" "chain"\n```\n\n---\n\n## Pro UrlScan Tips\n\n```text\ndomain:redacted.tld AND page.url:console\npage.url:dashboard AND page.url:welcome\n```\n\n---\n\n## Notes\n\n- OAuth bugs often appear low-impact alone but become critical when chained\n- Always manually verify UrlScan findings\n- Reading disclosed reports dramatically improves real-world intuition\n',
  },
  {
    slug: "subdomain-enumeration-workflow",
    title: "Subdomain Enumeration Workflow",
    description:
      "A practical workflow for collecting, deduplicating, and analyzing subdomains using popular reconnaissance tools",
    category: "Bug Hunting",
    order: 2,
    lastUpdated: "12/17/2025",
    content:
      "# Subdomain Enumeration Workflow\n\nThis note documents a simple but effective workflow for subdomain enumeration and DNS analysis during reconnaissance.\n\n## Step 1: Subdomain Enumeration\n\nUse multiple tools to maximize coverage.\n\n### subfinder\n\n```bash\nsubfinder -d target.com -all -recursive -o subs.txt\n```\n\n### assetfinder\n\n```bash\necho target.com | assetfinder -subs-only > assetfinder.txt\n```\n\n### findomain\n\n```bash\nfindomain -t target.com --quiet | tee findomain.txt\n```\n\n## Step 2: Combine and Deduplicate Results\n\nMerge all outputs and remove duplicates.\n\n```bash\ncat *.txt > all-subs.txt\nsort -u all-subs.txt > final-subdomains.txt\n```\n\n## Step 3: DNS Analysis with dnsx\n\nScan subdomains for DNS misconfigurations such as **SERVFAIL** and **REFUSED** responses.\n\n```bash\ndnsx -json -rcode servfail,refused -trace -t 500 -ns -r resolvers.txt -l final-subdomains.txt -o dnsx-output.json\n```\n\n## Step 4: Extract Takeover Candidates\n\nParse the dnsx JSON output to extract hosts and their nameserver chains.\n\n```bash\ncat dnsx-output.json | jq -r '\"\\(.host) \\(.trace.chain[-2].ns[])\"' | sort -u > dns-takeover-candidates.txt\n```\n\n## Output Files\n\n- `final-subdomains.txt` — clean list of unique subdomains\n- `dnsx-output.json` — DNS trace and response data\n- `dns-takeover-candidates.txt` — potential DNS takeover targets\n\n## Notes\n\n- Always use multiple resolvers for accuracy\n- SERVFAIL/REFUSED responses can indicate misconfigured or dangling DNS records\n- Manually verify takeover candidates before reporting\n",
  },
];
